(ns couverjure.tools.bsgen
  (:use clojure.xml couverjure.type-encoding)
  (:import (java.io File FileWriter PrintWriter)))

;
; Java source code generation
;

; generate java code (i.e class XX { ... })
(defmulti gen-java :kind)
; generate a reference to a type (i.e XX)
(defmulti gen-java-ref :kind)

(defmethod gen-java :structure [s]
  (java.text.MessageFormat/format
    (str
      "public class {0} '{'\n"
      "    public static class ByRef extends {0} implements Structure.ByReference '{'};\n"
      "    public static class ByVal extends {0} implements Structure.ByValue '{'};\n"
      "{1}'}'")
    (to-array [(:name s) (apply str (map gen-java (:fields s)))])))

(defmethod gen-java :field [f]
  (let [type (:type f)]
    ; need special handling for array fields as size suffix needs to go last
    (if (= :array (:kind type))
      (format "    public %s %s[];\n"
        (gen-java-ref (:type type))
        (:name f))
      (format "    public %s %s;\n"
        (gen-java-ref type)
        (:name f)))))

(defmethod gen-java-ref :structure [s]
  (:name s))

(defmethod gen-java-ref :array [a]
  (format "%s[%d]"
    (gen-java-ref (:type a)) (:size a)))

(defmethod gen-java-ref :bitfield [b]
  "long")

(defmethod gen-java-ref :pointer [p]
  ; have to peek inside the type to do this right
  (let [type (:type p)]
    (if (and (= :primitive (:kind type)))
      (condp = (:type type)
        :void "Pointer"
        :unknown "Pointer"
        :char "ByteByReference"
        :uchar "ByteByReference"
        :short "ShortByReference"
        :ushort "ShortByReference"
        :int "IntByReference"
        :uint "IntByReference"
        :long "IntByReference"
        :ulong "IntByReference"
        :longlong "LongByReference"
        :ulonglong "LongByReference"
        :float "FloatByReference"
        :double "DoubleByReference"
        "Pointer")
      (str (gen-java-ref type) ".ByRef"))))

(defmethod gen-java-ref :primitive [p]
  (.getName (primitive-java-types (:type p))))

;
; output file creation
;

(defn output-file [name pkg-name dir extn]
  (let [parts (seq (.split pkg-name "\\."))
        dirname (apply str (interpose \/ parts))
        rootdir (File. dir)
        pkgdir (File. rootdir dirname)]
    (.mkdirs pkgdir)
    (let [file (File. pkgdir (str name "." extn))]
      (println "output-file: " (.getAbsolutePath file))
      (if (.exists file) (.delete file))
      file)))

(defn java-output-file [name pkg-name dir]
  (output-file name pkg-name (str dir "/java") "java"))

(defn clojure-output-file [name pkg-name dir]
  (output-file name pkg-name (str dir "/clojure") "clj"))

;
; Generating java class files
;

(defn with-java-file [name dir pkg-name block]
  (with-open [raw-out (FileWriter. (java-output-file name pkg-name dir))
              out (PrintWriter. raw-out)]
    (block out)))

(defn gen-java-file [dir pkg-name struct]
  (let [objc-type (:objc-type struct)]
    (with-java-file (:name objc-type) dir pkg-name
      #(doto %
        (.println (str
          "/*\n"
          " * Generated by bstool\n"
          " */\n"))
        (.println (str "package " pkg-name ";"))
        (.println "")
        (.println "import com.sun.jna.*;")
        (.println "import com.sun.jna.ptr.*;")
        (.println "import org.couverjure.core.*;")
        (.println "")
        (.println (gen-java objc-type))
        ))))

; generating clojure source files

(defn with-clojure-file [name dir pkg-name block]
  (with-open [raw-out (FileWriter. (clojure-output-file name pkg-name dir))
              out (PrintWriter. raw-out)]
    (block out)))

(defn gen-clojure-framework [name dir clj-namespace java-namespace structs]
  (with-clojure-file name dir clj-namespace
    (fn [out] (doto out
      (.print (str
        ";\n"
        "; Generated by bstool\n"
        ";\n"))
      (.print
        (format "(ns %s.%s\n  (:import\n    (%s\n      %s)))\n"
          clj-namespace
          name
          java-namespace
          (apply str (interpose "\n      " (map #(:name (:objc-type %)) structs)))
          ))))))

;
; Working with bridgesupport XML elements
;

(defn struct-sig [struct]
  (or (:type64 (:attrs struct)) (:type (:attrs struct))))


(defn generate-framework-classes
  "Generates JNA-based java source files from the .bridgesupport XML file, using the supplied output directory and namespace"
  [bsfilename output-dir java-namespace clj-namespace]
  (let [file (File. bsfilename)
        xml (xml-seq (parse file))
        structs
        (for [elem xml :when (= :struct (:tag elem))]
          (assoc elem
            :objc-type (first (type-encoding (struct-sig elem)))))]
    (doall (for [struct structs]
      (gen-java-file output-dir java-namespace struct)
      ))
    (gen-clojure-framework "foundation" output-dir clj-namespace java-namespace structs)))

(if (= 4 (count *command-line-args*))
  (apply generate-framework-classes *command-line-args*)
  (println "Usage: bsgen <bridgesupport file> <output-dir> <java-namespace> <clj-namespace>"))

;    Copyright 2010 Mark Allerton. All rights reserved.
;
;    Redistribution and use in source and binary forms, with or without modification, are
;    permitted provided that the following conditions are met:
;
;       1. Redistributions of source code must retain the above copyright notice, this list of
;          conditions and the following disclaimer.
;
;       2. Redistributions in binary form must reproduce the above copyright notice, this list
;          of conditions and the following disclaimer in the documentation and/or other materials
;          provided with the distribution.
;
;    THIS SOFTWARE IS PROVIDED BY MARK ALLERTON ``AS IS'' AND ANY EXPRESS OR IMPLIED
;    WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
;    FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR
;    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
;    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
;    ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
;    ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;
;    The views and conclusions contained in the software and documentation are those of the
;    authors and should not be interpreted as representing official policies, either expressed
;    or implied, of Mark Allerton.

(ns couverjure.tools.java-model
  (:use
    clojure.test
    clojure.contrib.seq-utils
    couverjure.struct-utils
    couverjure.tools.formatter))

;
; java-model provides a code-model approach to emitting java source code
;

; the following tagged structs define the elements of our java code model
(deftagged type-spec :name)
(deftagged array-type-spec :name)
(deftagged variadic-type-spec :name)
(deftagged var-decl :type-spec :name)
(deftagged field-decl :modifiers :var-decl)
(deftagged method-decl :modifiers :type-spec :name :parameters :body)
(deftagged class-decl :modifiers :name :implements :extends :body)
(deftagged interface-decl :modifiers :name :extends :body)
(deftagged var-ref :object :name)
(deftagged modifier :name)
(deftagged package-decl :package-name)
(deftagged import-decl :package-name :class-name)
(deftagged statement :body)
(deftagged call-method :object :method :parameters)
(deftagged assignment :left :right)
(deftagged line-comment :text)
(deftagged multiline-comment :lines)
; break is a special element that allows clients to force line-breaks
(deftagged break)

; define the standard modifiers
(def public (modifier "public"))
(def static (modifier "static"))
(def abstract (modifier "abstract"))
(def native (modifier "native"))

; The emit-java multimethod emits "java source" for any code-model element
; This does not generate a formatted string. Instead it will return a sequence
; of strings and keywords, and subsequences of the same.
; The keywords act as "formatting instructions", and three keywords are
; supported:
;   :break - a line break
;   :indent - increase indentation level
;   :unindent - decrease indentation level
;
; The structure generated by emit-java can be rendered into formatted source
; using format-java-source.
; Subsequences in the output of emit-java are treated as if inlined into the parent
; sequence - i.e the tree is flattened and has no effect on formatting.

(defmulti emit-java
  ; Note that we make a psuedo-tag :seq for 'everything else' - we assume the model
  ; contains only tagged-structs or sequences
  (fn [m] (or (:tag m) :seq))) ;(if (sequential? m) :seq ) (throw (IllegalArgumentException. (str "Invalid arg to emit-java:" m)))))) 

(defn- emit-java-modifiers [mods]
  (if (and mods (> (count mods) 0))
    (emit-java mods)
    nil))

(defmethod emit-java :seq [s]
  (for [m s] (emit-java m)))

(defmethod emit-java :type-spec [ts]
  [ (:name ts) ])

(defmethod emit-java :array-type-spec [ts]
  [ (:name ts) :no-space "[]" ])

(defmethod emit-java :variadic-type-spec [ts]
  [ (:name ts) :no-space "..." ])

(defmethod emit-java :var-decl [vd]
  [ (emit-java (:type-spec vd)) (:name vd) ])

(defmethod emit-java :field-decl [fd]
  [ (emit-java-modifiers (:modifiers fd))
    (emit-java (:var-decl fd))
    ";" :break ])

(defmethod emit-java :method-decl [md]
  [(emit-java-modifiers (:modifiers md))
   (emit-java (:type-spec md))
   (:name md)
   "("
   (interpose "," (emit-java (:parameters md)))
   ")"
   (if (:body md)
     ["{" :indent :break
      (emit-java (:body md))
      :unindent "}" ]
     ";")
   :break ])

(defmethod emit-java :class-decl [cd]
  [ (emit-java-modifiers (:modifiers cd))
    "class" (:name cd)
    (if (:extends cd) "extends")
    (:extends cd)
    (if (:implements cd) "implements")
    (:implements cd)
    "{" :indent :break
    (emit-java (:body cd))
    :unindent
    "}" :break ])

(defmethod emit-java :interface-decl [cd]
  [ (emit-java-modifiers (:modifiers cd))
    "interface" (:name cd)
    (if (:extends cd) "extends")
    (:extends cd)
    "{" :indent :break
    (emit-java (:body cd))
    :unindent
    "}" :break ])

(defmethod emit-java :var-ref [vr]
  [ (:object vr) (if (:object vr) ".") (:name vr) ])

(defmethod emit-java :modifier [mod]
  [ (:name mod) ])

(defmethod emit-java :statement [st]
  [ (emit-java (:body st)) ";" :break ])

(defmethod emit-java :call-method [mi]
  [ (:object mi)
    (if (:object mi) ".")
    (:method mi)
    "("
    (interpose "," (emit-java (:parameters mi)))
    ")" ])

(defmethod emit-java :assignment [as]
  [ (emit-java (:left as)) "=" (emit-java (:right as)) ])

(defmethod emit-java :line-comment [c]
  [ "//" (:text c) :break ])

(defmethod emit-java :multiline-comment [c]
  [ "/*" :break (for [line (:lines c)] [ " *" line :break ]) " */" :break ])

(defmethod emit-java :break [c]
  [:break])

(defmethod emit-java :package-decl [p]
  [ "package" (:package-name p) ";" :break ])

(defmethod emit-java :import-decl [i]
  [ "import" (:package-name i) "." (:class-name i) ";" :break ])

;
; formatted output
;

(defn format-java-source
  [writer emitted-tree]
  (format-source writer emitted-tree 4 #{ "(" "[" "." } #{ "(" ")" "]" "," "." ";" }))

(defn format-java-model
  "Generate formatted source code from the model to the supplied writer"
  [writer model]
  (format-java-source writer (emit-java model)))

;    Copyright 2010 Mark Allerton. All rights reserved.
;
;    Redistribution and use in source and binary forms, with or without modification, are
;    permitted provided that the following conditions are met:
;
;       1. Redistributions of source code must retain the above copyright notice, this list of
;          conditions and the following disclaimer.
;
;       2. Redistributions in binary form must reproduce the above copyright notice, this list
;          of conditions and the following disclaimer in the documentation and/or other materials
;          provided with the distribution.
;
;    THIS SOFTWARE IS PROVIDED BY MARK ALLERTON ``AS IS'' AND ANY EXPRESS OR IMPLIED
;    WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
;    FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR
;    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
;    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
;    ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
;    ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;
;    The views and conclusions contained in the software and documentation are those of the
;    authors and should not be interpreted as representing official policies, either expressed
;    or implied, of Mark Allerton.

(ns couverjure.tools.java-model
  (:use
    clojure.test
    clojure.contrib.seq-utils
    couverjure.struct-utils))

;
; java-model provides a code-model approach to emitting java source code
;

; the following tagged structs define the elements of our java code model
(deftagged type-spec :name)
(deftagged array-type-spec :name)
(deftagged variadic-type-spec :name)
(deftagged var-decl :type-spec :name)
(deftagged field-decl :modifiers :var-decl)
(deftagged method-decl :modifiers :type-spec :name :parameters :body)
(deftagged class-decl :modifiers :name :implements :extends :body)
(deftagged interface-decl :modifiers :name :extends :body)
(deftagged var-ref :object :name)
(deftagged modifier :name)
(deftagged package-decl :package-name)
(deftagged import-decl :package-name :class-name)
(deftagged statement :body)
(deftagged call-method :object :method :parameters)
(deftagged assignment :left :right)
(deftagged line-comment :text)
; break is a special element that allows clients to force line-breaks
(deftagged break)

; define the standard modifiers
(def public (modifier "public"))
(def static (modifier "static"))
(def abstract (modifier "abstract"))
(def native (modifier "native"))

; The emit-java multimethod emits "java source" for any code-model element
; This does not generate a formatted string. Instead it will return a sequence
; of strings and keywords, and subsequences of the same.
; The keywords act as "formatting instructions", and three keywords are
; supported:
;   :break - a line break
;   :indent - increase indentation level
;   :unindent - decrease indentation level
;
; The structure generated by emit-java can be rendered into formatted source
; using format-java-source.
; Subsequences in the output of emit-java are treated as if inlined into the parent
; sequence - i.e the tree is flattened and has no effect on formatting.

(defmulti emit-java
  ; Note that we make a psuedo-tag :seq for 'everything else' - we assume the model
  ; contains only tagged-structs or sequences
  (fn [m] (or (:tag m) :seq))) 

(defn- emit-java-modifiers [mods]
  (if (and mods (> (count mods) 0))
    [(interpose " " (emit-java mods)) " "]
    nil))

(defmethod emit-java :seq [s]
  (for [m s] (emit-java m)))

(defmethod emit-java :type-spec [ts]
  [ (:name ts) ])

(defmethod emit-java :array-type-spec [ts]
  [ (:name ts) "[]" ])

(defmethod emit-java :variadic-type-spec [ts]
  [ (:name ts) "..." ])

(defmethod emit-java :var-decl [vd]
  [ (emit-java (:type-spec vd)) " " (:name vd) ])

(defmethod emit-java :field-decl [fd]
  [ (emit-java-modifiers (:modifiers fd))
    (emit-java (:var-decl fd))
    ";" :break ])

(defmethod emit-java :method-decl [md]
  [(emit-java-modifiers (:modifiers md))
   (emit-java (:type-spec md))
   (if (:type-spec md) " ")
   (:name md)
   "("
   (interpose ", " (emit-java (:parameters md)))
   ")"
   (if (:body md)
     [" {" :indent :break
      (emit-java (:body md))
      :unindent "}" ]
     ";")
   :break ])

(defmethod emit-java :class-decl [cd]
  [ (emit-java-modifiers (:modifiers cd))
    "class " (:name cd)
    (if (:implements cd) " implements ")
    (:implements cd)
    (if (:extends cd) " extends ")
    (:extends cd)
    " {" :indent :break
    (emit-java (:body cd))
    :unindent
    "}" :break ])

(defmethod emit-java :interface-decl [cd]
  [ (emit-java-modifiers (:modifiers cd))
    "interface " (:name cd)
    (if (:extends cd) " extends ")
    (:extends cd)
    " {" :indent :break
    (emit-java (:body cd))
    :unindent
    "}" :break ])

(defmethod emit-java :var-ref [vr]
  [ (:object vr) (if (:object vr) ".") (:name vr) ])

(defmethod emit-java :modifier [mod]
  [ (:name mod) ])

(defmethod emit-java :statement [st]
  [ (emit-java (:body st)) ";" :break ])

(defmethod emit-java :call-method [mi]
  [ (:object mi)
    (if (:object mi) ".")
    (:method mi)
    "("
    (interpose ", " (emit-java (:parameters mi)))
    ")" ])

(defmethod emit-java :assignment [as]
  [ (emit-java (:left as)) " = " (emit-java (:right as)) ])

(defmethod emit-java :line-comment [c]
  [ "// " (:text c) :break ])

(defmethod emit-java :break [c]
  [:break])

(defmethod emit-java :package-decl [p]
  [ "package " (:package-name p) ";" :break ])

(defmethod emit-java :import-decl [i]
  [ "import " (:package-name i) "." (:class-name i) ";" :break ])

;
; formatted output
;

; Defines the tab size. Indentation is done with spaces for tabs.
(def java-tab-size 4)

(defn format-java-source
  "Generate formatted source code from the results of emit-java.
 This uses the formatting-instruction keywords in the tree to control
 line-breaks and tabs, but otherwise just writes all of the strings
 in the tree to the output (assumed to be a java.io.Writer).
 nils in the tree are ignored (same as for 'str')"
  [writer emitted-tree]
  (loop [emitted (filter (complement nil?) (flatten emitted-tree))
         at-break true
         level 0]
    (let [s (first emitted)
          rest (rest emitted)]
       (cond
         ; nil means we're done
         (nil? s)
         nil
         ; line-break
         (= s :break)
         (do
           (.write writer "\n")
           (recur rest true level))
         ; indent
         (= s :indent)
         (recur rest at-break (inc level))
         ; unindent
         (= s :unindent)
         (recur rest at-break (dec level))
         ; everything else should be strings
         (string? s)
         (do
           (if at-break
              (.write writer (apply str (repeat (* level java-tab-size) \space))))
           (.write writer s)
           (recur rest false level))
    ))))

(defn format-java-model
  "Generate formatted source code from the model to the supplied writer"
  [writer model]
  (format-java-source writer (emit-java model)))
